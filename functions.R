## Load R packages quietly
suppressPackageStartupMessages({
  library(Seurat)
  library(scran)
  library(scater)
  library(data.table)
  library(tidyverse)
  library(patchwork)
  library(ggpubr)
  library(biomaRt)
  library(scDblFinder)
  library(SingleCellExperiment)
  library(BASiCS)
  library(arrow)
})



#' Automated Loading of Single-cell RNA-seq Count Matrices
#'
#' @description 
#' Streamlines the loading of compressed Matrix Market (.mtx) files from
#' single-cell RNA sequencing pipelines (e.g., 10x Genomics).
#' Validates file structure, loads data via `ReadMtx()`, and caches results as
#' an RDS file for efficient reuse. Designed for standardized project directories
#' where input files follow naming conventions.
#'
#' @param dir Character. Name of directory containing required files (no full path needed).
#'            The function automatically handles path construction using `file.path()`.
#'            Directory must contain:
#'            - `{prefix}.aggregated_counts.mtx.gz` (count matrix)
#'            - `{prefix}.aggregated_counts.mtx_rows.gz` (gene features)
#'            - `{prefix}.aggregated_counts.mtx_cols.gz` (cell barcodes)
#'            Example: "human_adult_kidney" (resolves to project_dir/human_adult_kidney/)
#'
#' @return A sparse matrix (dgCMatrix) of gene expression counts, returned invisibly. 
#'         Side effect: Saves matrix as "counts.rds" in specified directory.
#'
#' @section File Handling:
#' - Paths are automatically resolved using `file.path()`
#' - Files are validated against naming conventions
#' - Supports both relative and absolute directory names
#'
#' @section Validation Steps:
#' 1. Directory existence
#' 2. Unique filename prefix
#' 3. Required file presence (mtx/rows/cols)
#'
#' @examples
#' \dontrun{
#' # Minimal usage with project subdirectory
#' counts <- auto_load("human_adult_kidney")
#' 
#' # Full workflow example:
#' # 1. Process raw data (creates counts.rds)
#' auto_load("data/human_adult_kidney")  
#' 
#' # Output structure:
#' # human_adult_kidney/
#' # ├── counts.rds              # Created by this function
#' # ├── E-CURD-119.aggregated_counts.mtx.gz
#' # ├── E-CURD-119.aggregated_counts.mtx_rows.gz
#' # └── E-CURD-119.aggregated_counts.mtx_cols.gz
#' }
#'
#' @export
#' @importFrom Seurat ReadMtx
auto_load <- function(dir) {
  
  # Input validation
  if (!dir.exists(dir)) stop("Directory does not exist: ", dir)
  
  # File detection and preprocessing
  #   - List all .gz files in the directory (case-sensitive)
  files <- list.files(dir, pattern = "\\.gz$", full.names = TRUE)
  
  # Extract common prefix
  #   - Get text before first dot in filenames 
  #   - (e.g., "E-CURD-119" from "E-CURD-119.aggregated_counts.mtx.gz")
  prefix <- unique(sub("\\..*", "", basename(files)))
  if (length(prefix) != 1) {
    stop("Multiple filename prefixes detected: ", paste(prefix, collapse = ", "), 
         "\nFiles must share a common prefix (e.g., 'E-CURD-119.*.gz').")
  }
  
  # Construct standardized file paths
  #   - Expected file structure:
  #     - Count matrix:    {prefix}.aggregated_counts.mtx.gz
  #     - Cell barcodes:   {prefix}.aggregated_counts.mtx_cols.gz
  #     - Gene features:   {prefix}.aggregated_counts.mtx_rows.gz
  mtx_file <- file.path(dir, paste0(prefix, ".aggregated_counts.mtx.gz"))
  cells_file <- file.path(dir, paste0(prefix, ".aggregated_counts.mtx_cols.gz"))
  features_file <- file.path(dir, paste0(prefix, ".aggregated_counts.mtx_rows.gz"))
  
  # File existence validation
  required_files <- c(mtx_file, cells_file, features_file)
  missing_files <- required_files[!file.exists(required_files)]
  if (length(missing_files) > 0) {
    stop("Missing required files:\n", paste(missing_files, collapse = "\n"),
         "\nExpected files:\n- ", paste(basename(required_files), collapse = "\n- "))
  }
  
  # Data loading and saving
  #   - ReadMtx() is typically from Seurat or similar packages
  counts <- ReadMtx(
    mtx = mtx_file,           # Path to count matrix
    cells = cells_file,       # Path to cell barcodes
    features = features_file  # Path to gene annotations
  )
  
  # Save matrix in binary format for fast reloading
  saveRDS(counts, file = file.path(dir, "counts.rds"))
  
  # Return matrix without auto-printing
  invisible(counts)
}



#' Creation of SingleCellExperiment Object
#'
#' @description 
#' Constructs a SingleCellExperiment object from preprocessed count matrices (`counts.rds`) 
#' and pre-integrated metadata. Performs essential validation steps including: cell ID matching 
#' between counts/metadata, mitochondrial QC calculations, and retention of only "normal" samples.
#'
#' @param dir Character. Directory containing:
#'            - "counts.rds" file generated by `auto_load()`
#'            - "integrated_cell_metadata.rds" (pre-integrated metadata file)
#'            Paths are automatically resolved using `file.path()`.
#'
#' @return A filtered SingleCellExperiment object (invisibly) containing:
#'          - Raw counts matrix in assays slot
#'          - Integrated metadata in colData slot
#'          - QC metrics (mitochondrial %, library size)
#'         Side effect: Saves object as "sce.rds" in specified directory.
#'
#' @section Processing Pipeline:
#' 1. Validates required input files exist
#' 2. Loads count matrix and integrated metadata
#' 3. Verifies cell ID matching between counts and metadata
#' 4. Filters samples (retains only "normal" samples)
#' 5. Calculates mitochondrial QC metrics
#' 6. Saves processed SingleCellExperiment object
#'
#' @examples
#' \dontrun{
#' # Typical workflow:
#' sce <- create_sce_obj("human_adult_kidney")
#' 
#' # Output structure:
#' # human_adult_kidney/
#' # ├── counts.rds
#' # ├── integrated_cell_metadata.rds
#' # └── sce.rds
#' }
#'
#' @export
#' @importFrom SingleCellExperiment SingleCellExperiment
#' @importFrom scuttle addPerCellQC
#' @importFrom biomaRt useEnsembl getBM
#' @importFrom data.table fread
create_sce_obj <- function(dir){
  
  # Input Validation
  if (!dir.exists(dir)) {
    stop("Directory validation failed: '", dir, "' does not exist")
  }
  
  required_files <- c(
    file.path(dir, "counts.rds"),
    file.path(dir, "integrated_cell_metadata.rds")
  )
  
  missing_files <- required_files[!file.exists(required_files)]
  if (length(missing_files) > 0) {
    stop("Required file(s) missing: ", paste(basename(missing_files), collapse = ", "))
  }
  
  # Data Loading & Alignment
  #   - Ensures cell IDs match between counts and metadata
  meta <- read_rds(file.path(dir, "integrated_cell_metadata.rds"))
  counts <- read_rds(file.path(dir, "counts.rds"))
  if (!all(rownames(meta) %in% colnames(counts))) {
    stop("Metadata cell IDs not found in count matrix. First mismatched ID: ",
         setdiff(rownames(meta), colnames(counts))[1])
  }
  counts <- counts[, match(rownames(meta), colnames(counts))]
  
  # SCE Object Creation
  #   - Structure:
  #     - assays: Raw count matrix (dgCMatrix)
  #     - colData: All provided metadata columns
  sce <- SingleCellExperiment(assays = list(counts = counts),
                              colData = meta)
  
  # Sample Filtering
  #   - Critical: Only retains samples marked as "normal" in disease column
  if (!"disease" %in% colnames(colData(sce))) {
    stop("Required metadata column 'disease' missing")
  }
  sce <- sce[, sce$disease == "normal"]
  
  # Mitochondrial QC
  #   - Strategy: Fetch MT genes from Ensembl and validate their expression
  ensembl <- useEnsembl("ensembl", dataset = "hsapiens_gene_ensembl")
  mt_genes <- getBM(
    attributes = c("ensembl_gene_id", "chromosome_name"),
    filters = "chromosome_name",
    values = "MT",
    mart = ensembl
  )
  valid_mt_genes <- intersect(mt_genes$ensembl_gene_id, rownames(sce))
  
  # QC Metric Calculation
  #   - Adds columns to colData:
  #     - subsets_Mito_percent: % reads mapping to MT genes
  #     - sum/total/detected: Standard QC metrics
  sce <- addPerCellQC(sce, subsets = list(Mito = valid_mt_genes))
  
  # Data Persistence
  saveRDS(sce, file = file.path(dir, "sce.rds"))
  
  # Return matrix without auto-printing
  invisible(sce)
}



#' Generate and Save Quality Control Plots for SingleCellExperiment Objects
#'
#' @description 
#' Creates three diagnostic QC plots for single-cell RNA-seq data analysis:
#' 1) Library size vs detected genes (batch-aware), 
#' 2) Mitochondrial content distribution, and 
#' 3) Combined QC matrix. 
#' Automatically saves plots as high-resolution PNG files in a dedicated subdirectory
#' and returns the plot objects invisibly for programmatic access.
#'
#' @param dir Character. Path to directory containing:
#'            - "sce.rds" (SingleCellExperiment object with QC metrics)
#'            - Will create "QC plots" subdirectory for output
#'
#' @return A list of ggplot objects (invisible) containing:
#'         - $umi_vs_genes: Library size vs detected genes plot
#'         - $umi_vs_mito: Mitochondrial percentage distribution plot  
#'         - $qc_matrix: Combined QC metrics matrix plot
#'         Side effect: Generates PNG files in "QC plots" subdirectory.
#'
#' @section QC Plots Description:
#' 1. **BatchEffect_UMI_vs_Genes.png**: 
#'    - Visualizes technical batch effects and low-quality cells (bottom-left quadrant)
#'    - Uses viridis color palette for batch discrimination
#' 2. **BatchEffect_UMI_vs_MTpercent.png**: 
#'    - Identifies cells with potential apoptosis/stress (high MT%)
#'    - Includes 10% MT threshold (red dashed line)
#' 3. **QC_Filtering_Matrix.png**: 
#'    - Triparametric visualization of library size, gene detection, and MT%
#'    - Color gradient: blue (<5% MT) → grey (5-10%) → red (>10%)
#'
#' @examples
#' \dontrun{
#' # Basic usage after running pipeline functions:
#' # Assumes standard files are stored in project subdirectory "human_adult_kidney"
#' plots <- generate_qc_plots("human_adult_kidney")
#' 
#' # Programmatic access to plot objects:
#' plots$umi_vs_genes  # Access first plot
#' plots$umi_vs_mito   # Access second plot
#' 
#' # Full workflow example:
#' # 1. Process raw data (creates counts.rds and sce.rds)
#' auto_load("human_adult_kidney")  
#' create_sce_obj("human_adult_kidney", metadata_df)
#' 
#' # 2. Generate QC plots (auto-saved in "QC plots" subdirectory)
#' generate_qc_plots("human_adult_kidney")
#' 
#' # Output structure:
#' # human_adult_kidney/
#' # ├── QC plots/               # Created by this function
#' # │   ├── BatchEffect_UMI_vs_Genes.png
#' # │   ├── BatchEffect_UMI_vs_MTpercent.png
#' # │   └── QC_Filtering_Matrix.png
#' # ├── counts.rds             # From auto_load()
#' # └── sce.rds                # From create_sce_obj()
#' }
#' 
#' @export
#' @importFrom SingleCellExperiment plotColData
#' @importFrom ggplot2 ggsave theme_classic labs scale_x_continuous 
#' @importFrom scales viridis_pal
generate_qc_plots <- function(dir) {
  
  # Load sce object
  sce <- read_rds(file.path(dir, "sce.rds"))
  
  # Create QC output directory if not exists
  #   - dir: Parent directory path
  #   - qc_path: Subdirectory for storing QC plots ("QC plots")
  qc_path <- file.path(dir, "QC plots")
  if (!dir.exists(qc_path)) {
    dir.create(qc_path, recursive = TRUE)
  }
  
  # Plot 1: Library Size vs Detected Genes
  #   - x: Total UMI counts (log10-scaled)
  #   - y: Number of detected genes per cell
  #   - color: Batch information (technical replicates)
  #   - Visualizes potential low-quality cells (bottom-left quadrant)
  p1 <- plotColData(
    sce,
    x = "sum",                    # Total UMI counts per cell
    y = "detected",               # Number of detected genes
    colour_by = "BatchInfo"
  ) +
    labs(
      title = "Library Size vs Genes Detected",
      x = "Total UMI Counts (×10³)",
      y = "Number of Detected Genes",
      color = "ENA Sample"
    ) +
    theme_classic() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(face = "bold")
    ) +
    scale_x_continuous(labels = function(x) x/1000) +
    scale_color_viridis_d() # Color-blind friendly palette
  
  # Save Plot 1
  p1_path <- file.path(qc_path, "BatchEffect_UMI_vs_Genes.png")
  ggsave(p1_path, p1, width = 10, height = 6, dpi = 600)
  
  # Plot 2: Mitochondrial Gene Percentage
  #   - x: Total UMI counts (log10-scaled)
  #   - y: Percentage of mitochondrial reads (MT%)
  #   - Red dashed line: Typical QC threshold (10%)
  #   - High MT% indicates cell stress/apoptosis
  p2 <- plotColData(
    sce, 
    x = "sum",                   # Total UMI counts
    y = "subsets_Mito_percent",  # MT gene percentage
    colour_by = "BatchInfo"
  ) +
    labs(
      title = "Mitochondrial Gene Percentage",
      x = "Total UMI Counts (×10³)",
      y = "MT Gene % of Total Counts",
      color = "ENA Sample"
    ) +
    theme_classic() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      axis.title = element_text(size = 12),
      axis.text = element_text(size = 10),
      legend.title = element_text(face = "bold")
    ) +
    scale_x_continuous(labels = function(x) x/1000) +
    scale_color_viridis_d() +
    geom_hline(yintercept = 10, linetype = "dashed", color = "red") # QC threshold
  
  # Save Plot 2
  p2_path <- file.path(qc_path, "BatchEffect_UMI_vs_MTpercent.png")
  ggsave(p2_path, p2, width = 10, height = 6, dpi = 600)
  
  # Plot 3: Combined QC Metrics
  #   - x: Total UMI counts (log10-scaled)
  #   - y: Number of detected genes per cell
  #   - color: Mitochondrial gene percentage (MT%)
  #     - Blue: Low MT% (<5%) - healthy cells
  #     - Grey: Intermediate MT% (5-10%) - borderline cells
  #     - Red: High MT% (>10%) - potentially stressed/dying cells
  #   - Visualizes the relationship between library size, gene detection, and mitochondrial content
  #   - Helps identify low-quality cells in bottom-left quadrant (low UMI + low genes + high MT%)
  p3 <- plotColData(
    sce,
    x = "sum",                         # Total UMI counts per cell
    y = "detected",                    # Number of detected genes
    colour_by = "subsets_Mito_percent" # Mitochondrial percentage
  ) + 
    labs(
      title = "Library Size vs Genes Detected",
      subtitle = "Colored by Mitochondrial Gene Percentage (MT%)",
      x = "Total UMI Counts (×10³)",
      y = "Number of Detected Genes",
      color = "MT Gene %"
    ) +
    scale_color_gradient2(
      low = "blue", 
      mid = "grey", 
      high = "red", 
      midpoint = 10
    ) +
    theme_classic() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
      plot.subtitle = element_text(hjust = 0.5),
      axis.title = element_text(size = 12, face = "bold"),
      legend.title = element_text(face = "bold")
    )
  
  # Save Plot 3
  p3_path <- file.path(qc_path, "QC_Filtering_Matrix.png")
  ggsave(p3_path, p3, width = 10, height = 6, dpi = 600)
  
  # Return plot objects invisibly for programmatic access
  invisible(list(
    umi_vs_genes = p1,
    umi_vs_mito = p2,
    qc_matrix = p3
  ))
}



#' Automated Calculation and Export of Single-Cell QC Metrics
#'
#' @description 
#' Performs comprehensive quality control (QC) analysis on single-cell RNA-seq data 
#' stored in a SingleCellExperiment object. Computes three critical QC metrics using 
#' Median Absolute Deviation (MAD) for outlier detection and returns results both as 
#' CSV files and R objects. Implements dual filtering strategies combining:
#' 1) Fixed biological thresholds (library size, gene detection, MT%)
#' 2) Adaptive MAD-based statistical thresholds
#'
#' @param dir Character. Path to directory containing "sce.rds" (SingleCellExperiment object 
#'            with precomputed QC metrics from `create_sce_obj()`). Automatically creates 
#'            "QC metrics" subdirectory if missing.
#'
#' @return A list containing (invisibly):
#' - $qc_stats: Data frame of per-cell QC metrics (sum, detected, subsets_Mito_*)
#' - $thresholds: Data frame of MAD-based filtering thresholds and cell counts
#' Side effects: Saves both data frames as CSV files in "QC metrics" subdirectory.
#'
#' @section QC Methodology:
#' 1. **Multi-modal Quality Assessment**:
#'    - Library size: Identifies cells with insufficient sequencing depth
#'    - Gene detection: Flags cells with abnormal transcriptional activity
#'    - MT%: Detects apoptotic/stressed cells via mitochondrial contamination
#' 2. **Adaptive Thresholding**:
#'    - Uses `scater::isOutlier()` with 3 MAD thresholds (99% non-outlier retention)
#'    - Log-transform for UMI/gene counts to handle skewed distributions
#'
#' @section Output Structure:
#' 1. **qc_stats** Data Frame:
#'    - Rows: Cell barcodes (rownames preserved)
#'    - Columns: 
#'      * sum: Total UMI counts per cell
#'      * detected: Genes detected per cell
#'      * subsets_Mito_*: Mitochondrial metrics
#' 2. **thresholds** Data Frame:
#'    - Metric: QC metric name
#'    - Threshold: Computed MAD cutoff value
#'    - Cells_Filtered: Count of outlier cells
#'
#' @examples
#' \dontrun{
#' # Standard workflow with CSV and rds output
#' qc_metrics_calculation("human_adult_kidney")
#'
#' # Advanced usage with programmatic access:
#' qc_data <- qc_metrics_calculation("human_adult_kidney")
#' head(qc_data$qc_stats)  # Inspect per-cell metrics
#' qc_data$thresholds      # View filtering thresholds
#'
#' # Output structure:
#' # human_adult_kidney/
#' # ├── QC metrics/
#' # │   ├── qc_metrics.rds       # Per-cell statistics
#' # │   └── qc_thresholds.csv   # Filtering thresholds
#' # ├── sce.rds
#' # └── ...
#' }
#'
#' @export
#' @importFrom scater perCellQCMetrics isOutlier
#' @importFrom SingleCellExperiment colData
#' @importFrom readr write_csv
qc_metrics_calculation <- function(dir) {
  
  # Load sce object
  sce <- read_rds(file.path(dir, "sce.rds"))
  
  # Create QC output directory if not exists
  #   - dir: Parent directory path
  #   - qc_path: Subdirectory for storing QC metrics ("QC metrics")
  qc_path <- file.path(dir, "QC metrics")
  if (!dir.exists(qc_path)) {
    dir.create(qc_path, recursive = TRUE)
  }
  
  # Detect outlier cells using Median Absolute Deviation (MAD):
  #   - lib: Filters cells with unusually low library size (total UMIs)
  #   - gene: Filters cells with too few detected genes
  #   - mito: Filters cells with excessive mitochondrial percentage
  qc_stats <- sce %>% perCellQCMetrics() %>% as.data.frame() %>%
    cbind(colData(sce)[, c("subsets_Mito_sum",
                           "subsets_Mito_detected",
                           "subsets_Mito_percent")])
  
  # Detect outlier cells using Median Absolute Deviation (MAD):
  #   - lib: Filters cells with unusually low library size (total UMIs)
  #   - gene: Filters cells with too few detected genes
  #   - mito: Filters cells with excessive mitochondrial percentage
  thresholds <- list(
    lib = isOutlier(qc_stats$sum, log = TRUE, type = "lower"),
    gene = isOutlier(qc_stats$detected, log = TRUE, type = "lower"),
    mito = isOutlier(qc_stats$subsets_Mito_percent, type = "higher")
  )
  
  # Create aggregated summary of filtering results:
  #   - Metric: Type of QC metric being evaluated
  #   - Threshold: Calculated cutoff value for each metric
  #   - Cells_Filtered: Count of cells removed by each filter
  summary_df <- data.frame(
    Metric = c("Total UMIs", "Detected Genes", "Mitochondrial Percentage"),
    Threshold = c(
      attr(thresholds$lib, "thresholds")["lower"],
      attr(thresholds$gene, "thresholds")["lower"],
      attr(thresholds$mito, "thresholds")["higher"]
    ),
    Cells_Filtered = c(
      sum(thresholds$lib),
      sum(thresholds$gene),
      sum(thresholds$mito)
    )
  )
  
  # Save results to CSV files
  saveRDS(qc_stats, file.path(qc_path, "qc_metrics.rds"))
  write_csv(summary_df, file.path(qc_path, "qc_thresholds.csv"))
  
  # Return results invisibly for programmatic access
  invisible(list(
    qc_stats = qc_stats,
    thresholds = summary_df
  ))
}



#' Rigorous Quality Control Filtering for SingleCellExperiment Objects
#'
#' @description 
#' Applies multi-dimensional quality control filters to single-cell RNA-seq data,
#' removing low-quality cells and genes based on customizable thresholds. Implements
#' a standardized filtering pipeline addressing four key QC dimensions:
#' 1) Library size (sequencing depth), 2) Gene detection sensitivity, 
#' 3) Mitochondrial contamination, and 4) Gene detection robustness. 
#' Returns filtered results both as RDS file and R object for downstream analysis.
#'
#' @param dir Character. Directory containing "sce.rds" file generated by 
#'            `create_sce_obj()`. Paths are resolved using `file.path()`.
#' @param qc.lib Numeric. Minimum library size threshold (total UMIs per cell).
#'               Default = 1000 (recommended for human/mouse datasets).
#' @param qc.nexprs Numeric. Minimum number of detected genes per cell.
#'                  Default = 500 (balances sensitivity/specificity).
#' @param qc.mito Numeric. Maximum mitochondrial gene percentage threshold.
#'                Default = 10% (established apoptosis cutoff).
#' @param keep.genes Numeric. Minimum number of cells where a gene must be 
#'                   detected. Default = 20 (ensures robust expression).
#'
#' @return A filtered SingleCellExperiment object (invisibly). Contains:
#'         - Raw counts matrix meeting all QC thresholds
#'         - Retained cell/gene metadata in colData/rowData
#'         - Preserved dimensionality reductions (PCA/UMAP/etc.)
#'         Side effect: Saves object as "sce_filtered.rds" in target directory.
#'
#' @section QC Filtering Logic:
#' 1. **Cell-level Filters**:
#'    - Retains cells with >`qc.lib` UMIs (low sequencing depth removal)
#'    - Keeps cells detecting >`qc.nexprs` genes (empty droplet exclusion)
#'    - Excludes cells with MT% >`qc.mito` (apoptotic/stressed cells)
#' 2. **Gene-level Filters**:
#'    - Removes genes detected in <`keep.genes` cells (sporadic noise reduction)
#'
#' @section Technical Implementation:
#' - Uses efficient sparse matrix operations via `Matrix::rowSums`
#' - Preserves all metadata, reducedDims, and altExps during filtering
#' - Maintains backward compatibility with scater/scran workflows
#'
#' @examples
#' \dontrun{
#' # Standard workflow with default thresholds
#' filtered_sce <- sce_filter("human_adult_kidney")
#' 
#' # Custom thresholds for sensitive applications
#' filtered_sce <- sce_filter("mouse_embryo", 
#'                           qc.lib = 500, 
#'                           qc.nexprs = 200,
#'                           qc.mito = 5,
#'                           keep.genes = 10)
#'                           
#' # Access filtered data
#' head(counts(filtered_sce))
#' 
#' # Output structure:
#' # human_adult_kidney/
#' # ├── sce.rds          # Input from create_sce_obj()
#' # └── sce_filtered.rds # Created by this function
#' }
#'
#' @export
#' @importFrom SingleCellExperiment counts
#' @importFrom Matrix rowSums
sce_filter <- function(
    dir,
    qc.lib = 1000,
    qc.nexprs = 500,
    qc.mito = 10,
    keep.genes = 20
) {
  
  # Load sce object with validation
  if (!file.exists(file.path(dir, "sce.rds"))) {
    stop("Required file missing: 'sce.rds' not found in ", dir)
  }
  sce <- read_rds(file.path(dir, "sce.rds"))
  
  # Cell-level QC thresholds
  lib_threshold <- sce$sum > qc.lib  # Sequencing depth filter
  nexpr_threshold <- sce$detected > qc.nexprs  # Gene detection filter
  mito_threshold <- sce$subsets_Mito_percent < qc.mito  # MT content filter
  
  # Gene-level QC threshold
  keep_genes <- rowSums(counts(sce) > 0) > keep.genes # Expression prevalence
  
  # Apply filters
  sce <- sce[keep_genes, lib_threshold & nexpr_threshold & mito_threshold]
  
  # Save filtered object
  saveRDS(sce, file = file.path(dir, "sce_filtered.rds"))
  
  # Return filtered object invisibly
  invisible(sce)
}



#' Comprehensive Normalization and Processing Pipeline for SingleCellExperiment Objects
#'
#' @description 
#' Performs end-to-end normalization and quality processing of single-cell RNA-seq data,
#' including: 1) Library size normalization, 2) Highly variable gene selection,
#' 3) Dimensionality reduction, and 4) Doublet detection/removal. Implements the
#' Bioconductor-standard analysis pipeline with optimized parameters for scRNA-seq data.
#'
#' @param dir Character. Directory containing "sce_filtered.rds" file generated by 
#'            `sce_filter()`. Paths are resolved using `file.path()`.
#'
#' @return A processed SingleCellExperiment object (invisibly) containing:
#'         - Normalized counts (logcounts assay)
#'         - HVG selection results (rowData)
#'         - PCA/UMAP embeddings (reducedDims)
#'         - Doublet classification metadata (colData)
#'         Side effect: Saves object as "sce_filtered_normalized.rds" in target directory.
#'
#' @section Processing Pipeline:
#' 1. **Normalization**:
#'    - Applies `scater::logNormCounts()` with library size factors
#'    - Transforms raw counts to log2(CPM+1) normalized expression
#' 2. **Feature Selection**:
#'    - Models per-gene variance with `scran::modelGeneVar()`
#'    - Selects top 2000 HVGs using biological component variance
#' 3. **Dimensionality Reduction**:
#'    - Computes PCA using IRLBA algorithm (50 PCs)
#'    - Calculates UMAP embedding with cosine metric
#' 4. **Doublet Filtering**:
#'    - Identifies doublets using `scDblFinder` with batch-aware detection
#'    - Retains only singlets for downstream analysis
#'
#' @section Technical Details:
#' - Normalization: Uses size factors accounting for library composition biases
#' - HVG Selection: Separates technical noise from biological variation
#' - UMAP Parameters: Optimized for single-cell data (n_neighbors=15, min_dist=0.1)
#' - Doublet Detection: Incorporates batch-specific artifact profiles
#'
#' @examples
#' \dontrun{
#' # Standard workflow continuation:
#' # 1. Load and filter data
#' auto_load("human_adult_kidney")
#' create_sce_obj("human_adult_kidney", metadata)
#' sce_filter("human_adult_kidney")
#' 
#' # 2. Normalize and process
#' processed_sce <- sce_normalize("human_adult_kidney")
#' 
#' # Access normalized data
#' head(logcounts(processed_sce))
#' 
#' # Output structure:
#' # human_adult_kidney/
#' # ├── sce_filtered.rds              # Input from sce_filter()
#' # └── sce_filtered_normalized.rds  # Created by this function
#' }
#'
#' @export
#' @importFrom scater logNormCounts
#' @importFrom scran modelGeneVar getTopHVGs
#' @importFrom scDblFinder scDblFinder
#' @importFrom BiocSingular IrlbaParam
#' @importFrom uwot umap
sce_normalize <- function(dir) {
  
  # Input validation
  if (!file.exists(file.path(dir, "sce_filtered.rds"))) {
    stop("Required input file missing: 'sce_filtered.rds' not found in ", dir)
  }
  
  # Load filtered SCE object
  sce <- read_rds(file.path(dir, "sce_filtered.rds"))
  
  # Data normalization using scater::logNormCounts
  #   - Transforms raw counts to log-normalized counts
  #   - Stores results in new 'logcounts' assay slot
  sce <- logNormCounts(sce)
  
  # Decompose technical and biological variation:
  #   - Uses scran::modelGeneVar to estimate per-gene variance
  #   - Separates technical noise from biological variation
  dec <- modelGeneVar(sce)
  
  # Select top 2000 highly variable genes (HVGs):
  #   - Identifies genes with highest biological variation
  #   - Focuses downstream analysis on biologically relevant signals
  hvg <- getTopHVGs(dec, n = 2000)
  
  # Dimensional reduction pipeline (PCA -> UMAP):
  #   - PCA: Reduces dimensions while preserving maximum variance
  #     - Uses IRLBA algorithm for efficient computation on large datasets
  #     - Only uses selected HVGs to reduce technical noise
  #     - Stores results in reducedDim(sce, "PCA")
  sce <- runPCA(
    sce,
    subset_row = hvg,
    exprs_values = "logcounts",
    BSPARAM = BiocSingular::IrlbaParam()
  )
  
  # Detect and filter doublets using scDblFinder:
  #   - Identifies potential doublets based on artificial nearest-neighbor profiles
  #   - Uses batch information to account for batch-specific effects
  #   - Adds doublet classification metadata to colData
  sce <- scDblFinder(sce, samples = "BatchInfo")
  
  # Filter to retain only singlets:
  #   - Removes cells classified as doublets (scDblFinder.class != "singlet")
  #   - Reduces potential artifacts from multiple cells captured in one droplet
  sce <- sce[, sce$scDblFinder.class == "singlet"] 
  
  # Calculate UMAP embedding:
  #   - Non-linear dimensionality reduction for visualization
  #   - Uses PCA results as input (50 dimensions by default)
  #   - Parameters tuned for balance between local/global structure:
  #     - n_neighbors = 15: Balances local/global structure preservation
  #     - min_dist = 0.1: Controls cluster compactness
  #     - metric = "cosine": Suitable for scRNA-seq data
  reducedDim(sce, "UMAP") <- calculateUMAP(
    sce, 
    dimred = "PCA",
    n_neighbors = 15,
    min_dist = 0.1,
    metric = "cosine"
  )
  
  # Save processed data
  saveRDS(sce, file = file.path(dir, "sce_filtered_normalized.rds"))
  
  # Return processed object invisibly
  invisible(sce)
}



#' Systematic Batch Effect Evaluation and Visualization Pipeline
#'
#' @description 
#' Performs integrated assessment of technical batch effects in single-cell RNA-seq data through:
#' 1) Dimensionality-reduction visualization (UMAP colored by batch)
#' 2) Quantitative batch dispersion metrics calculation
#' 3) Automated report generation with diagnostic plots and scores
#' Supports both known batch effects (recorded experimental conditions) and latent technical variations.
#'
#' @param dir Character. Directory containing:
#'            - "sce_filtered_normalized.rds" (Processed SingleCellExperiment object)
#'            - Creates/updates "QC plots" and "QC metrics" subdirectories
#'
#' @return A list containing (invisibly):
#'         - $batch_plot: ggplot object of UMAP visualization
#'         - $batch_metrics: data.frame with quantitative batch metrics:
#'           * Centroid_X/Y: Mean UMAP coordinates per batch
#'           * Avg_Distance: Mean dispersion from centroid (rescaled 0-1)
#'           * Tissue: Sample identifier from directory name
#'         Side effects: Saves plot (PNG) and metrics (CSV) in respective subdirectories.
#'
#' @section Batch Effect Analysis Methodology:
#' 1. **Visual Diagnostics**:
#'    - Projects cells in UMAP space colored by batch metadata
#'    - Identifies batch-specific clustering patterns
#' 2. **Quantitative Scoring**:
#'    - Calculates centroid positions for each batch group
#'    - Measures average Euclidean distance from centroid (dispersion)
#'    - Rescales scores to 0-1 range for cross-dataset comparability
#'
#' @examples
#' \dontrun{
#' # Standard workflow continuation:
#' batch_results <- process_batch_effects("human_adult_kidney")
#' 
#' # Access quantitative metrics:
#' batch_results$batch_metrics
#'
#' # Output structure:
#' # human_adult_kidney/
#' # ├── QC plots/
#' # │   └── UMAP Batch Clustering.png      # Visual diagnostics
#' # ├── QC metrics/
#' # │   └── batch_effect_scores.csv       # Quantitative metrics
#' # ├── sce_filtered_normalized.rds
#' # └── ...
#' }
#'
#' @export
#' @importFrom scater plotReducedDim
#' @importFrom ggplot2 ggtitle theme_classic theme element_text
#' @importFrom readr write_csv
process_batch_effects <- function(dir) {
  
  # Input validation
  if (!file.exists(file.path(dir, "sce_filtered_normalized.rds"))) {
    stop("Required input file missing: 'sce_filtered_normalized.rds' not found in ", dir)
  }
  
  # Load normalized SingleCellExperiment object
  sce <- read_rds(file.path(dir, "sce_filtered_normalized.rds"))
  
  # Initialize output directory structure
  #   - qc_plot_path: Stores visual diagnostics ("QC plots/")
  #   - qc_metrics_path: Stores numerical metrics ("QC metrics/")
  #   - Uses recursive creation to handle nested directory structures
  qc_plot_path <- file.path(dir, "QC plots")
  if (!dir.exists(qc_plot_path)) {
    dir.create(qc_plot_path, recursive = TRUE)
  }
  qc_metrics_path <- file.path(dir, "QC metrics")
  if (!dir.exists(qc_metrics_path)) {
    dir.create(qc_metrics_path, recursive = TRUE)
  }
  
  # Plot 4: Batch effect visualization - UMAP colored by batch
  #   - Generates UMAP plot colored by BatchInfo metadata
  #   - Uses reduced dimensions stored in "UMAP" slot
  #   - Applies classic theme with centered bold title
  #   - Saves high-resolution PNG (600dpi) with specified dimensions
  p4 <- plotReducedDim(
    sce,
    dimred = "UMAP",
    colour_by = "BatchInfo",
    point_size = 1.5
  ) +
    ggtitle("UMAP by Batch") +
    theme_classic() +
    theme(plot.title = element_text(hjust = 0.5, face = "bold"))
  
  # Save UMAP charts
  #   - Stores plot in QC subdirectory
  #   - Filename: "UMAP Batch Clustering.png"
  #   - Dimensions: 8x6 inches
  umap_path <- file.path(qc_plot_path, "UMAP Batch Clustering.png")
  ggsave(umap_path, p4, width = 8, height = 6, dpi = 600)
  
  # Batch Effect Quantification
  #   - Extracts UMAP coordinates from reducedDim slot
  #   - Calculates per-batch metrics:
  #     - Centroid positions (mean UMAP1/UMAP2)
  #     - Average distance from centroid (dispersion measure)
  #   - Adds tissue identifier from directory name
  #   - Rescales batch effect score to 0-1 range for comparability
  batch_score <- reducedDim(sce, "UMAP") %>% 
    as.data.frame() %>%
    mutate(Batch = sce$BatchInfo) %>% 
    group_by(Batch) %>% 
    summarise(
      Centroid_X = mean(UMAP1),
      Centroid_Y = mean(UMAP2),
      Avg_Distance = mean(sqrt((UMAP1 - mean(UMAP1))^2 + (UMAP2 - mean(UMAP2))^2)),
      .groups = "drop"
    ) %>%
    mutate(
      Tissue = basename(dir),
      Batch_Effect_Score = scales::rescale(Avg_Distance, to = c(0, 1))
    )
  
  # Save batch scoring forms
  #   - Stores quantitative metrics in CSV format
  #   - Filename: "batch_effect_scores.csv"
  #   - Contains columns: Batch, Centroid_X/Y, Avg_Distance, Tissue, Score
  write_csv(batch_score, file.path(qc_metrics_path, "batch_effect_scores.csv"))
  
  # Return results invisibly
  invisible(list(
    batch_plot = p4,
    batch_metrics = batch_score
  ))
}



#' Bayesian MCMC Inference for Single-Cell Gene Expression Variability
#'
#' @description 
#' Executes Markov Chain Monte Carlo (MCMC) sampling using the BASiCS framework to quantify 
#' biological and technical variability in single-cell RNA-seq data. Implements:
#' 1) Hierarchical modeling of gene expression variability
#' 2) Regression-based technical noise decomposition
#' 3) Parallelized sampling for computational efficiency
#' Returns both on-disk chain storage and in-memory results for downstream analysis.
#'
#' @param dir Character. Directory containing:
#'            - "sce_filtered_normalized.rds" (Processed SingleCellExperiment object)
#'            - Creates chain storage subdirectories via BASiCS internal handling
#'
#' @return An object of class `BASiCS_Chain` (invisibly) containing:
#'         - $mu: Posterior samples for mean expression parameters
#'         - $delta: Posterior samples for biological overdispersion
#'         - $epsilon: Posterior samples for technical noise components
#'         - $theta: Posterior samples for cell-specific normalization factors
#'         Side effects: Saves complete MCMC chains in subdirectories via BASiCS internal storage.
#'
#' @section MCMC Configuration:
#' 1. **Sampling Strategy**:
#'    - 30,000 total iterations (15,000 burn-in + 15,000 retained)
#'    - Thinning interval of 15 to reduce autocorrelation
#'    - Parallel computation across 22 threads
#' 2. **Model Specification**:
#'    - Empirical Bayes priors for mean expression (stabilizes inference)
#'    - Regression-based technical noise decomposition
#'    - Hierarchical modeling of biological variability
#'
#' @section Technical Implementation:
#' - Uses adaptive MCMC tuning during burn-in phase
#' - Implements efficient sparse matrix operations
#' - Automatically handles chain storage management
#' - Maintains compatibility with BASiCS analysis suite
#'
#' @examples
#' \dontrun{
#' # Standard workflow continuation:
#' # 1. Process data through normalization pipeline
#' sce_normalize("human_adult_kidney")
#' 
#' # 2. Run Bayesian inference
#' mcmc_chains <- Run_MCMC("human_adult_kidney")
#' 
#' # Access posterior summaries:
#' BASiCS_Summary(mcmc_chains)
#' 
#' # Output structure:
#' # human_adult_kidney/
#' # ├── chain.Rds      # MCMC chain storage
#' # ├── sce_filtered_normalized.rds
#' # └── ...
#' }
#'
#' @export
#' @importFrom BASiCS BASiCS_MCMC BASiCS_PriorParam
Run_MCMC <- function(dir) {
  
  # Input validation
  if (!file.exists(file.path(dir, "sce_filtered_normalized.rds"))) {
    stop("Required input file missing: 'sce_filtered_normalized.rds' not found in ", dir)
  }
  
  # Load sce object
  sce <- read_rds(file.path(dir, "sce_filtered_normalized.rds"))
  
  # Execute Bayesian MCMC inference
  #   - N: Total iterations (balancing convergence vs runtime)
  #   - Thin: Reduces autocorrelation while preserving information
  #   - Burn: Discards initial samples during adaptation phase
  #   - Regression: Separates technical/biological variability
  #   - PriorParam: Stabilizes inference via empirical Bayes
  #   - Threads: Enables parallel chain computation
  BASiCS_MCMC(
    sce,
    N = 30000,                     # Total iterations
    Thin = 15,                     # Keep every 15th sample
    Burn = 15000,                  # Initial samples discarded
    Regression = TRUE,             # Account for technical noise via regression
    WithSpikes = FALSE,            # No spike-in controls available
    PriorParam = BASiCS_PriorParam(
      sce,
      PriorMu = "EmpiricalBayes"   # Empirical Bayes priors for mean expression
    ),
    Threads = 22,                  # Parallel processing
    StoreChains = TRUE,            # Save complete MCMC chains
    StoreDir = dir
  )
  
  # Return MCMC chains invisibly for programmatic access
  invisible(chain)
}



#' MCMC Convergence Diagnostics for Single-Cell Variability Analysis
#'
#' @description 
#' Generates diagnostic plots assessing Markov Chain Monte Carlo (MCMC) convergence 
#' for gene expression variability parameters estimated by BASiCS. Implements:
#' 1) Geweke's convergence diagnostic for stationarity testing
#' 2) Effective Sample Size (ESS) calculation for sampling efficiency
#' 3) Combined visualization of diagnostic metrics
#' Saves publication-ready figures while returning plot objects for programmatic access.
#'
#' @param dir Character. Directory containing:
#'            - "chain.rds" (BASiCS_Chain object from Run_MCMC())
#'            Creates subdirectory "MCMC Convergence diagnostic" if nonexistent
#'
#' @return Invisible list containing:
#'         - $geweke: ggplot object of Geweke diagnostic plot
#'         - $ess: ggplot object of ESS diagnostic plot
#'         Side effects: Saves combined diagnostic plot as "geweke_ess.png" (600dpi)
#'
#' @section Diagnostic Metrics:
#' 1. **Geweke Diagnostic**:
#'    - Tests for non-convergence by comparing early/late chain segments
#'    - Z-scores >2 indicate potential convergence issues
#' 2. **Effective Sample Size**:
#'    - Quantifies independent information content in correlated samples
#'    - Values <100 suggest insufficient sampling efficiency
#'
#' @section Visualization Features:
#' - Unified plot layout with publication-quality styling
#' - Standardized dimensions (14x8 inches) for multi-panel figures
#' - Custom theme preserving BASiCS plot aesthetics
#' - Automatic directory creation for output organization
#'
#' @examples
#' \dontrun{
#' # After running MCMC inference:
#' Run_MCMC("human_adult_liver")
#' 
#' # Generate diagnostics:
#' diag_plots <- mcmc_diag("human_adult_liver")
#' 
#' # Access individual plots:
#' diag_plots$geweke  # View Geweke diagnostic
#' diag_plots$ess     # View ESS plot
#' 
#' # Output structure:
#' # human_adult_liver/
#' # ├── MCMC Convergence diagnostic/
#' # │   └── geweke_ess.png
#' # ├── chain.rds
#' # └── ...
#' }
#'
#' @export
#' @importFrom BASiCS BASiCS_DiagPlot
#' @importFrom ggplot2 theme_classic labs ggsave
#' @importFrom patchwork plot_annotation
mcmc_diag <- function(dir) {
  
  # Input validation
  if (!file.exists(file.path(dir, "chain.rds"))) {
    stop("Required input file missing: 'chain.rds' not found in ", dir)
  }
  
  diag_path <- file.path(dir, "MCMC Convergence diagnostic")
  if (!dir.exists(diag_path)) {
    dir.create(diag_path, recursive = TRUE)
  }
  
  chain <- read_rds(file.path(dir, "chain.rds"))
  
  geweke <- BASiCS_DiagPlot(chain, Param = "mu", Measure = "geweke") +
    theme_classic() +
    labs(title = "Geweke Diagnostic")
  
  ess <- BASiCS_DiagPlot(chain, Param = "mu", Measure = "ess") +
    theme_classic() +
    labs(title = "Effective Sample Size (ESS)")
  
  geweke_ess <- geweke + ess + 
    plot_annotation(
      tag_levels = "A",
      title = "MCMC Convergence Diagnostics for Gene Expression Parameter (Mu)",
      theme = theme(
        plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        plot.caption = element_text(hjust = 1)
      )
    )
  
  geweke_ess_path <- file.path(diag_path, "geweke_ess.png")
  ggsave(geweke_ess_path, geweke_ess, width = 14, height = 8, dpi = 600)
}



#' Bayesian Integration of Gene Expression Variability Patterns
#'
#' @description 
#' Integrates results from BASiCS MCMC inference to classify genes by their expression variability:
#' 1) Identifies Highly Variable Genes (HVGs) with biological variability above threshold
#' 2) Detects Lowly Variable Genes (LVGs) with constrained biological variability 
#' 3) Merges results with gene metadata in SingleCellExperiment object
#' Implements rigorous statistical thresholds derived from posterior distributions.
#'
#' @param dir Character. Directory containing:
#'            - "sce_filtered_normalized.rds" (Processed SingleCellExperiment)
#'            - "chain.rds" (BASiCS_Chain object from Run_MCMC())
#'
#' @return An augmented SingleCellExperiment object (invisibly) containing:
#'         - $VG: Variability classification (HVG/LVG/Neither) in rowData
#'         - $Mu: Posterior mean expression estimates
#'         - $Delta/Epsilon: Biological/technical variability parameters
#'         Side effects: Saves CSV of variability metrics and integrated RDS file.
#'
#' @section Variability Classification Methodology:
#' 1. **Threshold Definition**:
#'    - HVG: Epsilon > log(2) (2-fold biological variability)
#'    - LVG: Epsilon < -log(2) (constrained biological variability)
#' 2. **Statistical Integration**:
#'    - Merges MCMC posterior estimates with gene metadata
#'    - Maintains gene exclusivity (HVG/LVG/Neither)
#'    - Preserves all original rowData annotations
#'
#' @examples
#' \dontrun{
#' # Standard workflow continuation:
#' # 1. Run MCMC inference first
#' Run_MCMC("human_adult_kidney")
#' 
#' # 2. Integrate variability results
#' integrated_sce <- vg_integration("human_adult_kidney")
#' 
#' # Access variability classifications:
#' table(rowData(integrated_sce)$VG)
#' 
#' # Output structure:
#' # human_adult_kidney/
#' # ├── variable_genes.csv       # Full variability metrics
#' # └── sce_vg_integrated.rds    # Augmented SCE object
#' }
#'
#' @export
#' @importFrom BASiCS BASiCS_DetectHVG BASiCS_DetectLVG
#' @importFrom SummarizedExperiment rowData rowData<-
vg_integration <- function(dir) {
  
  # Input validation
  required_files <- c("sce_filtered_normalized.rds", "chain.rds")
  for (f in required_files) {
    if (!file.exists(file.path(dir, f))) {
      stop("Required file missing: '", f, "' not found in ", dir)
    }
  }
  
  # Load preprocessed data objects
  #   - sce: Normalized SingleCellExperiment with gene metadata
  #   - chain: BASiCS_Chain from MCMC sampling
  sce <- read_rds(file.path(dir, "sce_filtered_normalized.rds"))
  chain <- read_rds(file.path(dir, "chain.rds"))
  
  # Detect Highly Variable Genes (HVGs)
  #   - EpsilonThreshold = log(2): 2-fold biological variability minimum
  #   - Uses posterior probability thresholds from MCMC chains
  hvg <- BASiCS_DetectHVG(chain, EpsilonThreshold = log(2))
  
  # Detect Lowly Variable Genes (LVGs) 
  #   - EpsilonThreshold = -log(2): Constrained biological variability
  #   - Complementary to HVG detection
  lvg <- BASiCS_DetectLVG(chain, EpsilonThreshold = -log(2))
  
  # Merge HVG/LVG results into unified data frame
  #   - Retains all genes (Filter=FALSE) for comprehensive analysis
  #   - Combines Mu (mean), Delta (overdispersion), Epsilon (residual) estimates
  #   - Adds suffixes to distinguish HVG/LVG-specific columns
  vg <- merge(
    as.data.frame(lvg, Filter = FALSE), # LVG results (include all genes)
    as.data.frame(hvg, Filter = FALSE), # HVG results (include all genes)
    by = c("GeneName", "GeneIndex", "Mu", "Delta", "Epsilon"), # Merge keys
    suffixes = c("LVG", "HVG")          # Suffixes for overlapping columns
  )
  
  # Save complete variability metrics
  write_csv(vg, file.path(dir, "variable_genes.csv"))
  
  # Classify genes by variability pattern
  #   - Mutually exclusive categories (HVG/LVG/Not HVG or LVG)
  #   - Based on posterior probability thresholds
  vg$VG <- "Not HVG or LVG"
  vg$VG[vg$HVG] <- "HVG"
  vg$VG[vg$LVG] <- "LVG"
  
  # Integrate results with gene metadata
  #   - Preserves original rowData annotations
  #   - Adds variability classification and parameters
  rowData(sce) <- merge(
    data.frame(ensembl_gene_id = rownames(sce), rowData(sce)),
    vg,
    by.x = "ensembl_gene_id",
    by.y = "GeneName",
    sort = FALSE
  )
  
  # Save augmented SingleCellExperiment
  saveRDS(sce, file = file.path(dir, "sce_vg_integrated.rds"))
  
  # Return sce object invisibly
  invisible(sce)
}



#' Integrated miRNA Target Identification Pipeline Using TargetScan
#'
#' @description 
#' Performs comprehensive miRNA target identification by integrating TargetScan's:
#' 1) Conserved/non-conserved miRNA family annotations
#' 2) Context++ score predictions
#' Implements rigorous filtering based on both absolute score thresholds and percentile rankings.
#' Automatically checks for existing results to avoid redundant computations.
#'
#' @param score Numeric. Maximum context++ score threshold (lower values indicate stronger predictions).
#' @param percentile Numeric. Minimum percentile ranking threshold (higher values indicate stronger predictions).
#' @param species Integer. NCBI Taxonomy ID for target species (default: 9606 for human).
#'
#' @return A data frame (invisibly) containing:
#'         - $Gene.ID: Target gene identifiers
#'         - $miR.Family: Targeting miRNA families
#'         - $context...score: Context++ scores
#'         - $context...score.percentile: Percentile rankings
#'         Side effect: Saves filtered targets with parameter-specific filename in TargetScan directory.
#'
#' @section TargetScan Integration Methodology:
#' 1. **Pre-computation Check**:
#'    - Verifies existence of previously computed results for identical parameters
#'    - Skips computation if results exist (idempotent operation)
#' 2. **Data Loading**:
#'    - Combines conserved/non-conserved family annotations
#'    - Merges context++ scores from both prediction sets
#' 3. **Species Filtering**:
#'    - Retains only targets for specified taxonomy ID
#'    - Handles gene ID formatting (e.g., stripping version numbers)
#' 4. **miRNA Processing**:
#'    - Normalizes miRNA family nomenclature
#'    - Expands composite family annotations (e.g., "miR-1/2/3")
#' 5. **Statistical Filtering**:
#'    - Applies dual thresholds (absolute score + percentile)
#'    - Maintains many-to-many miRNA:gene relationships
#'
#' @examples
#' \dontrun{
#' # Standard usage for human targets:
#' target_results <- target_identify(
#'   score = -0.2, 
#'   percentile = 90
#' )
#' 
#' # For mouse targets (taxonomy ID 10090):
#' mouse_targets <- target_identify(
#'   score = -0.15,
#'   percentile = 85,
#'   species = 10090
#' )
#' 
#' # Output structure:
#' # TargetScan/
#' # ├── Conserved_Family_Info.txt                     # Input files
#' # ├── Nonconserved_Family_Info.txt
#' # ├── Conserved_Site_Context_Scores.txt
#' # ├── Nonconserved_Site_Context_Scores.txt
#' # └── Interested_Targets_0.2_90_9606.csv  # Parameter-specific output
#' }
#'
#' @export
#' @importFrom dplyr filter mutate left_join
#' @importFrom tidyr unnest
#' @importFrom readr write_csv
target_identify <- function(score, percentile, species = 9606) {
  
  # Generate parameter-specific output filename
  output_file <- sprintf("Interested_Targets_%.2f_%d_%d.csv", 
                         score, percentile, species)
  output_path <- file.path("TargetScan", output_file)
  
  # Check for existing results
  if (file.exists(output_path)) {
    message("Pre-computed results found for these parameters. Loading existing file: ", output_file)
    return(invisible(read_csv(output_path)))
  }
  
  # Input validation
  if (!dir.exists("TargetScan")) {
    stop("TargetScan directory not found. Please ensure it exists with required input files.")
  }
  
  required_files <- c(
    "Conserved_Family_Info.txt",
    "Nonconserved_Family_Info.txt",
    "Conserved_Site_Context_Scores.txt",
    "Nonconserved_Site_Context_Scores.txt"
  )
  
  missing_files <- required_files[!file.exists(file.path("TargetScan", required_files))]
  if (length(missing_files) > 0) {
    stop("Missing required TargetScan input files: ", paste(missing_files, collapse = ", "))
  }
  
  # Load TargetScan annotation files
  conserved_family <- read.delim(
    file.path("TargetScan", "Conserved_Family_Info.txt"), 
    stringsAsFactors = FALSE
  )
  nonconserved_family <- read.delim(
    file.path("TargetScan", "Nonconserved_Family_Info.txt"), 
    stringsAsFactors = FALSE
  )
  conserved_score <- read.delim(
    file.path("TargetScan", "Conserved_Site_Context_Scores.txt"), 
    stringsAsFactors = FALSE
  )
  nonconserved_score <- read.delim(
    file.path("TargetScan", "Nonconserved_Site_Context_Scores.txt"), 
    stringsAsFactors = FALSE
  )
  
  # Combine and filter datasets by species
  family <- rbind(conserved_family, nonconserved_family) %>%
    filter(Species.ID == species)
  scores <- rbind(conserved_score, nonconserved_score) %>%
    filter(Gene.Tax.ID == species)
  
  # Target identification pipeline
  targets <- family %>%
    mutate(
      miR.Family_split = strsplit(miR.Family, "/"),
      original_prefix = sub("/.*", "", miR.Family)
    ) %>% 
    unnest(miR.Family_split) %>% 
    mutate(
      miR.Family = ifelse(
        !grepl("^(miR-|let-)", miR.Family_split),
        ifelse(
          grepl("^miR-", original_prefix),
          paste0("miR-", miR.Family_split),
          ifelse(
            grepl("^let-", original_prefix),
            paste0("let-", miR.Family_split),
            miR.Family_split
          )
        ),
        miR.Family_split
      ),
      Gene.ID = sub("\\..*", "", Gene.ID),
      miR.Family = gsub("miR-26", "miR-26a", miR.Family),
      miR.Family = gsub("miR-99", "miR-99a", miR.Family)
    ) %>%
    dplyr::select(-miR.Family_split, -original_prefix) %>%
    left_join(
      scores %>%
        mutate(
          Gene.ID = sub("\\..*", "", Gene.ID),
          miRNA = sub("^hsa-", "", miRNA)
        ),
      by = c("Gene.ID", "miR.Family" = "miRNA"),
      relationship = "many-to-many"
    ) %>%
    filter(
      context...score < score,
      context...score.percentile > percentile
    )
  
  # Save filtered targets with parameter-specific filename
  write_csv(targets, file = output_path)
  message("Results saved to: ", output_file)
  
  invisible(targets)
}



#' Integrated miRNA-Gene Interaction Analysis Pipeline
#'
#' @description 
#' Performs bidirectional integration of miRNA-target relationships by:
#' 1) Summarizing miRNA targeting patterns per gene (gene-centric view)
#' 2) Aggregating target genes per miRNA (miRNA-centric view)
#' 3) Annotating single-cell data with target gene status
#' Combines TargetScan predictions with single-cell variability classifications.
#'
#' @param dir Character. Directory containing:
#'            - "sce_vg_integrated.rds" (SingleCellExperiment with variability annotations)
#'            - "TargetScan/Interested_Targets.csv" (TargetScan predictions from target_identify())
#'
#' @return A list containing (invisibly):
#'         - $gene_summary: data.frame with gene-centric metrics:
#'           * target.number: Count of targeting miRNAs per gene
#'           * miRNA: Concatenated miRNA family list
#'           * VG: Variability classification from single-cell data
#'         - $mirna_summary: data.frame with miRNA-centric metrics:
#'           * gene.number: Count of target genes per miRNA
#'           * Gene.ID: Concatenated target gene list
#'         - $sce: Augmented SingleCellExperiment object with:
#'           * miRNA_target: Binary annotation of target status
#'         Side effects: Saves CSV summaries and integrated RDS file.
#'
#' @section Analysis Methodology:
#' 1. **Gene-Centric Analysis**:
#'    - Counts regulatory miRNAs per gene
#'    - Merges single-cell variability classifications
#'    - Handles genes missing in single-cell data
#' 2. **miRNA-Centric Analysis**:
#'    - Quantifies target gene breadth per miRNA family
#'    - Preserves original TargetScan identifiers
#' 3. **Single-Cell Integration**:
#'    - Annotates target genes in rowData
#'    - Maintains all existing metadata columns
#'
#' @examples
#' \dontrun{
#' # Standard workflow continuation:
#' # 1. Run TargetScan target identification first
#' target_identify(score = -0.2, percentile = 90)
#' 
#' # 2. Perform miRNA-gene integration
#' interaction_results <- gene_mirna_interaction("human_adult_kidney")
#' 
#' # Access gene-centric summary:
#' head(interaction_results$gene_summary)
#' 
#' # Output structure:
#' # human_adult_kidney/
#' # ├── gene_mirna.csv         # Gene-centric summary
#' # ├── mirna_gene.csv        # miRNA-centric summary
#' # └── sce_target_integrated.rds  # Augmented SCE object
#' }
#'
#' @export
#' @importFrom dplyr select group_by summarise ungroup left_join
#' @importFrom tidyr replace_na
#' @importFrom readr write_csv read_csv
gene_mirna_interatcion <- function(dir, score, percentile, species = 9606 ) {
  
  targets_file <- sprintf("Interested_Targets_%.2f_%d_%d.csv", score, percentile, species)
  
  # Input validation
  required_files <- c(
    file.path("TargetScan", targets_file),
    file.path(dir, "sce_vg_integrated.rds")
  )
  for (f in required_files) {
    if (!file.exists(f)) {
      stop("Required file missing: '", f, "' not found")
    }
  }
  # Load preprocessed data
  #   - targets: TargetScan predictions from target_identify()
  #   - sce: SingleCellExperiment with variability annotations
  targets <- read_csv(file.path("TargetScan", targets_file)) %>%
    mutate(miR.Family = str_replace(miR.Family, "\\.\\d+$", "")) %>%
    group_by(miR.Family, Gene.ID) %>%
    arrange(context...score) %>%
    slice_min(context...score, n = 1) %>%
    ungroup() %>%
    distinct(miR.Family, Gene.ID, .keep_all = TRUE)
  sce <- read_rds(file.path(dir, "sce_vg_integrated.rds"))
  
  # Gene-centric summary
  #   - Counts targeting miRNAs per gene (target.number)
  #   - Concatenates miRNA family lists (miR-1/2/3 format)
  #   - Merges single-cell variability classifications (VG)
  #   - Handles genes missing in single-cell data ("SCE NotFound")
  gene_mirna_summary <- targets %>%
    dplyr::select(Gene.ID, miR.Family) %>%
    group_by(Gene.ID) %>%
    summarise(
      target.number = n(), # Count the number of miRNAs targeted by each gene
      miRNA = paste(unique(miR.Family), collapse = "/")    # Merge all miRNAs
    ) %>%
    ungroup() %>%
    left_join(
      as.data.frame(rowData(sce)) %>%
        dplyr::select(ensembl_gene_id, VG) %>%
        mutate(ensembl_gene_id = sub("\\..*", "", ensembl_gene_id)),
      by = c("Gene.ID" = "ensembl_gene_id")
    ) %>%
    mutate(VG = replace_na(VG, "SCE Not Found"))
  
  # Save gene-centric summary
  write_csv(gene_mirna_summary, file = file.path(dir, "gene_mirna.csv"))
  
  
  # miRNA-centric summary
  #   - Counts target genes per miRNA family (gene.number)
  #   - Concatenates target gene lists (ENSG1/2/3 format)
  mirna_gene_summary <- targets %>%
    dplyr::select(miR.Family, Gene.ID) %>%
    group_by(miR.Family) %>%
    summarise(
      gene.number = n(),      # Count the number of genes targeted by each miRNA
      Gene.ID = paste(unique(Gene.ID), collapse = "/")   # Merge all Ensembl IDs
    ) %>%
    ungroup()
  
  # Save miRNA-centric summary
  write_csv(mirna_gene_summary, file = file.path(dir, "mirna_gene.csv"))
  
  # Annotate single-cell data
  #   - Adds binary miRNA_target column (Target/Non-target)
  #   - Preserves all existing rowData
  rowData(sce)$miRNA_target <- ifelse(
    rownames(sce) %in% gene_mirna_summary$Gene.ID,
    "Target",
    "Non-target"
  )
  
  # Save sce object
  saveRDS(sce, file = file.path(dir, "sce_target_integrated.rds"))
  
  # Return results invisibly
  invisible(list(
    gene_summary = gene_mirna_summary,
    mirna_summary = mirna_gene_summary,
    sce = sce
  ))
}



#' Tissue-Specific miRNA-Gene Interaction Validation Pipeline
#'
#' @description 
#' Validates miRNA-gene interactions by integrating:
#' 1) Organ-specific miRNA expression from miRNATissueAtlas
#' 2) Precomputed miRNA-gene interactions from TargetScan
#' 3) Single-cell variability classifications
#' Generates tissue-filtered interaction summaries and annotated single-cell data.
#'
#' @param dir Character. Directory containing:
#'            - "mirna_gene.csv" (miRNA-gene interactions from gene_mirna_interaction())
#'            - "sce_vg_integrated.rds" (SingleCellExperiment object)
#' @param organ Character. Tissue name matching miRNATissueAtlas metadata (e.g. "kidney")
#'
#' @return Invisibly returns a list containing:
#'         - $mirna_summary: data.frame with miRNA-centric metrics:
#'           * exp.mean: Mean expression in specified tissue
#'           * gene.number: Count of target genes per miRNA
#'           * Gene.ID: Concatenated target gene list
#'         - $gene_summary: data.frame with gene-centric metrics:
#'           * target.number: Count of validated targeting miRNAs
#'           * miRNA: Concatenated miRNA list
#'           * VG: Variability classification from single-cell data
#'         - $sce: Augmented SingleCellExperiment object with:
#'           * miRNA_target: Binary annotation of tissue-validated target status
#'         Side effects: Saves CSV summaries and RDS file.
#'
#' @section Validation Methodology:
#' 1. **Tissue Expression Filtering**:
#'    - Calculates mean miRNA expression per tissue
#'    - Retains only miRNAs with non-zero expression (mean > 0)
#'    - Standardizes miRNA nomenclature (removes "hsa-" prefix)
#' 2. **Interaction Validation**:
#'    - Filters interactions to tissue-expressed miRNAs
#'    - Preserves original TargetScan interaction metrics
#' 3. **Single-Cell Integration**:
#'    - Updates target status based on tissue validation
#'    - Maintains all existing metadata columns
#'
#' @examples
#' \dontrun{
#' # After running gene_mirna_interaction():
#' kidney_results <- gene_mirna_organ_valid(
#'   dir = "human_adult_kidney",
#'   organ = "kidney"
#' )
#' 
#' # Output structure:
#' # human_adult_kidney/
#' # ├── mirna_gene_organ_valid.csv  # Tissue-filtered miRNA summary
#' # ├── gene_mirna_organ_valid.csv   # Tissue-validated gene targets
#' # └── sce_target_organ_valid.rds   # Annotated SCE object
#' }
#'
#' @export
#' @importFrom dplyr select filter group_by summarise rename arrange distinct
#' @importFrom tidyr separate_rows replace_na
#' @importFrom readr read_csv write_csv
#' @importFrom arrow read_parquet
gene_mirna_organ_valid <- function(dir, organ) {
  
  # Input validation - check required files exist
  required_files <- c(
    file.path(dir, "mirna_gene.csv"),
    file.path(dir, "sce_target_integrated.rds"),
    file.path("miRNATissueAtlas", "expression.parquet"),
    file.path("miRNATissueAtlas", "metadata.parquet")
  )
  for (f in required_files) {
    if (!file.exists(f)) {
      stop("Required file missing: '", f, "' not found")
    }
  }
  
  # Load preprocessed data:
  #   - mirna_gene: TargetScan predictions from gene_mirna_interaction()
  #   - sce: SingleCellExperiment with variability annotations
  #   - obs/metadata: Tissue expression atlas (parquet format)
  mirna_gene <- read_csv(file.path(dir, "mirna_gene.csv"))
  sce <- read_rds(file.path(dir, "sce_target_integrated.rds"))
  obs <- read_parquet(file.path("miRNATissueAtlas" , "expression.parquet"))
  meta <- read_parquet(file.path("miRNATissueAtlas", "metadata.parquet"))
  
  # Calculate tissue-specific miRNA expression:
  #   - Merge expression data with tissue metadata
  #   - Filter for specified organ
  #   - Calculate column means (per-miRNA expression)
  #   - Remove non-expressed miRNAs (mean = 0)
  #   - Standardize miRNA names (remove "hsa-" prefix)
  mirna_means <- merge(obs, meta, by = "__index_level_0__") %>%
    filter(Tissue == organ) %>%
    dplyr::select(2:(ncol(.)-6)) %>%
    colMeans(na.rm = TRUE) %>%
    enframe(name = "miRNA", value = "mean") %>%
    arrange(desc(mean)) %>%
    filter(mean != 0) %>%
    mutate(miRNA = str_remove(miRNA, "^hsa-"))
  
  # Filter miRNA-gene interactions:
  #   - Merge with tissue expression data (inner join)
  #   - Retain only interactions with expressed miRNAs
  #   - Rename mean expression column for clarity
  mirna_gene <- merge(
    mirna_means,
    mirna_gene,
    by.x = "miRNA",
    by.y = "miR.Family",
    all = FALSE
  ) %>% rename(exp.mean = mean)
  
  # Save filtered miRNA-centric summary
  write_csv(mirna_gene, file = file.path(dir, "mirna_gene_organ_valid.csv"))
  
  # Regenerate gene-centric statistics:
  #   - Expand concatenated Gene.ID lists
  #   - Remove empty/NA gene IDs
  #   - Deduplicate miRNA-gene pairs
  #   - Calculate targeting metrics per gene
  #   - Merge single-cell variability classifications
  #   - Label genes missing in single-cell data
  gene_mirna <- mirna_gene %>%
    dplyr::select(-exp.mean) %>%
    separate_rows(Gene.ID, sep = "/") %>%
    filter(!is.na(Gene.ID), str_trim(Gene.ID) != "") %>%
    distinct(Gene.ID, miRNA, .keep_all = TRUE) %>%
    group_by(Gene.ID) %>%
    summarise(
      target.number = n(),
      miRNA = paste(unique(miRNA), collapse = "/")
    ) %>%
    ungroup() %>%
    left_join(
      as.data.frame(rowData(sce)) %>%
        dplyr::select(ensembl_gene_id, VG) %>%
        mutate(ensembl_gene_id = sub("\\..*", "", ensembl_gene_id)),
      by = c("Gene.ID" = "ensembl_gene_id")
    ) %>%
    mutate(VG = replace_na(VG, "SCE NotFound"))
  
  # Save validated gene-centric summary
  write_csv(gene_mirna, file = file.path(dir, "gene_mirna_organ_valid.csv"))
  
  # Annotate single-cell data:
  #   - Add binary target status (Target/Non-target)
  #   - Based on tissue-validated interactions
  rowData(sce)$miRNA_target <- ifelse(
    rownames(sce) %in% gene_mirna$Gene.ID,
    "Target",
    "Non-target"
  )
  
  # Save sce object
  saveRDS(sce, file = file.path(dir, "sce_target_organ_valid.rds"))
  
  # Return results invisibly
  invisible(list(
    mirna_summary = mirna_gene,
    gene_summary = gene_mirna,
    sce = sce
  ))
}



#' Integrated miRNA-Gene Interaction Processing Pipeline
#'
#' @description 
#' Orchestrates a complete miRNA-gene interaction analysis workflow with:
#' 1) Base interaction analysis (TargetScan + single-cell integration)
#' 2) Optional tissue-specific validation (miRNATissueAtlas)
#' 3) Optional experimental validation (miRTarBase)
#' Modular design allows flexible execution of validation steps.
#'
#' @param dir Character. Directory containing:
#'            - Input/Output files from pipeline steps
#'            - Requires TargetScan predictions from target_identify()
#'            - Requires "sce_vg_integrated.rds" for base analysis
#' @param score Numeric. TargetScan context++ score threshold (default=0)
#' @param percentile Numeric. Conservation percentile cutoff (default=90)
#' @param species Integer. Species ID (default=9606 for human)
#' @param valid Character. Validation type: 
#'              - NULL (base analysis only)
#'              - "organ" (tissue-specific validation)
#' @param organ Character. Tissue name for validation (e.g. "kidney"), 
#'              required when valid != NULL
#'
#' @return Invisibly returns SingleCellExperiment object with:
#'         - Base analysis: miRNA_target annotations
#'         - Organ validation: tissue-filtered targets
#'         Side effects: Saves intermediate files at each step
#'
#' @section Workflow Details:
#' 1. **Base Analysis**:
#'    - Runs gene_mirna_interaction() with specified parameters
#'    - Generates miRNA-gene interaction summaries
#'    - Annotates single-cell data with target status
#'
#' 2. **Tissue Validation** (valid="organ"):
#'    - Filters interactions by tissue-specific miRNA expression
#'    - Requires organ-specific miRNATissueAtlas data
#'    - Updates target annotations in SingleCellExperiment
#'
#' @examples
#' \dontrun{
#' # Base analysis only
#' base_results <- gene_mirna_process("human_data")
#' 
#' # With kidney tissue validation
#' kidney_results <- gene_mirna_process(
#'   dir = "human_kidney",
#'   valid = "organ",
#'   organ = "kidney"
#' )
#' }
#'
#' @export
gene_mirna_process <- function(
    dir,
    score = 0, percentile = 90, species = 9606,
    valid = NULL, organ = NULL
    ) {
  
  # Parameter validation
  if (!is.null(valid) && !valid %in% c("organ")) {
    stop("Invalid 'valid' parameter. Must be NULL or 'organ'")
  }
  if (is.null(valid) && !is.null(organ)) {
    stop("'organ' must be NULL when 'valid' is NULL")
  }
  if (!is.null(valid) && is.null(organ)) {
    stop("'organ' cannot be NULL when 'valid' is specified")
  }
  
  # Execute base interaction analysis
  #   - Runs gene_mirna_interaction() with provided parameters
  #   - Returns annotated SingleCellExperiment object
  message("Executing base miRNA-gene interaction analysis...")
  result <- gene_mirna_interatcion(dir, score, percentile, species)
  
  # Execute validation steps if requested
  if (valid == "organ") {
    # Tissue-specific validation:
    #   - Filters interactions by organ-specific miRNA expression
    #   - Updates target annotations in SCE object
    message("\nAdding organ-specific validation for: ", organ)
    gene_mirna_organ_valid(dir, organ)
    result <- readRDS(file.path(dir, "sce_target_organ_valid.rds"))
  }
  
  # Return results invisibly
  invisible(result)
}



#' Gene-Level Statistical Analysis Pipeline
#'
#' @description 
#' Computes gene-level statistics integrating:
#' 1) Single-cell variability classifications (HVG/LVG)
#' 2) miRNA target status (Target/Non-target)
#' 3) UTR sequence features from TargetScan
#' Supports validation-level filtering through the 'valid' parameter.
#'
#' @param dir Character. Directory containing:
#'            - "sce_target_[type].rds" (SingleCellExperiment object)
#'            - Requires "TargetScan/UTR_Sequences.txt" for UTR features
#' @param species Integer. Species ID (default=9606 for human)
#' @param valid Character. Validation level:
#'              - NULL (base analysis, uses "sce_target_integrated.rds")
#'              - "organ" (tissue-validated, uses "sce_target_organ_valid.rds")
#'
#' @return Invisibly returns a list containing:
#'         - $gene_stats: data.frame with per-gene metrics:
#'           * gene_class: Variability classification (HVG/LVG)
#'           * is_target: Logical miRNA target status
#'           * UTR_sequence: Full 3'UTR sequence
#'           * utr_length: Effective length (excluding gaps)
#'         - $stats_summary: data.frame with grouped statistics:
#'           * mean_utr_length: Average by VG/target status
#'           * count: Genes per category
#'           * UTR_missing: Count of genes lacking UTR data
#'         Side effects: Saves CSV files with detailed and summary statistics.
#'
#' @section Analysis Methodology:
#' 1. **Data Integration**:
#'    - Loads appropriate SCE object based on validation level
#'    - Merges TargetScan UTR sequences (handling versioned Ensembl IDs)
#'    - Calculates effective UTR length excluding gaps ("-")
#'
#' 2. **Statistical Summarization**:
#'    - Groups by variability class and target status
#'    - Computes mean UTR lengths with missing data counts
#'    - Formats output for readability (Target/Non-target labels)
#'
#' 3. **Validation Handling**:
#'    - NULL: Uses base miRNA-target predictions
#'    - "organ": Filters to tissue-expressed miRNA targets
#'
#' @examples
#' \dontrun{
#' # Base analysis
#' base_stats <- obtain_gene_stats("human_adult_kidney")
#' 
#' # Kidney tissue-validated analysis
#' kidney_stats <- obtain_gene_stats(
#'   dir = "human_adult_kidney",
#'   valid = "organ"
#' )
#' 
#' # Output structure:
#' # human_adult_kidney/
#' # ├── gene_stats.csv          # Detailed gene features
#' # └── gene_stats_summary.csv  # Grouped statistics
#' }
#'
#' @export
#' @importFrom dplyr filter group_by summarise rename mutate left_join
#' @importFrom readr read_delim write_csv
obtain_gene_stats <- function(dir, species = 9606, valid = NULL) {
  
  # Parameter validation
  if (!is.null(valid) && !valid %in% c("organ", "exp")) {
    stop("Invalid 'valid' parameter. Must be NULL or 'organ'")
  }
  
  # Determine input file based on validation level
  sce_file <- if (is.null(valid)) {
    "sce_target_integrated.rds"
  } else {
    switch(valid,
           "organ" = "sce_target_organ_valid.rds",
           stop("Invalid validation type"))
  }
  
  # Input validation
  required_files <- c(
    sce = file.path(dir, sce_file),
    utr = file.path("TargetScan", "UTR_Sequences.txt")
  )
  missing_files <- !file.exists(required_files)
  if (any(missing_files)) {
    stop(paste(
      "Missing required files:",
      paste(names(required_files)[missing_files], collapse = ", "),
      "\nExpected paths:",
      paste(required_files[missing_files], collapse = "\n  ")
    ))
  }
  
  # Load preprocessed data
  #   - sce: SingleCellExperiment with target annotations
  #   - utr: TargetScan UTR sequences for specified species
  sce <- read_rds(file.path(dir, sce_file))
  utr <- read_delim(file.path("TargetScan", "UTR_Sequences.txt")) %>% 
    filter(`Species ID` == species)
  
  # Gene-level feature compilation
  #   - Classifies genes by variability (HVG/LVG/Neither)
  #   - Annotates miRNA target status (TRUE/FALSE)
  #   - Merges UTR sequences (handling versioned ENSEMBL IDs)
  #   - Calculates effective UTR length (excluding gaps)
  gene_stats <- as.data.frame(rowData(sce)) %>%
    mutate(
      gene_class = factor(VG, levels = c("HVG", "LVG", "Not HVG or LVG")),
      is_target = miRNA_target == "Target"
    )  %>%
    left_join(
      utr %>% mutate(`Gene ID` = gsub("(.*)\\.[0-9]+", "\\1", `Gene ID`)) %>%
        dplyr::select(`Gene ID`, `UTR sequence`),
      by = c("ensembl_gene_id" = "Gene ID")  
    ) %>%
    rename(UTR_sequence = `UTR sequence`) %>%
    mutate(utr_length = nchar(gsub("-", "", UTR_sequence))) %>%
    group_by(ensembl_gene_id) %>%
    slice_max(utr_length, n = 1) %>%
    ungroup()
  
  # Save detailed gene features
  write_csv(gene_stats, file.path(dir, "gene_stats.csv"))
  
  # Grouped statistical summary
  #   - Filters to variable genes (HVG/LVG)
  #   - Calculates mean UTR length per category
  #   - For each gene, keep the the largest utr_length
  #   - Ff multiple UTRs have equal length, one is kept at random
  #   - Counts genes and missing UTR data
  #   - Formats target status for readability
  stats_summary <- gene_stats %>%
    group_by(ensembl_gene_id) %>%
    slice_max(utr_length, n = 1) %>%
    ungroup() %>%
    group_by(VG, is_target) %>%
    summarise(
      mean_utr_length = mean(utr_length, na.rm = TRUE),
      count = n(),
      UTR_missing = sum(is.na(utr_length))
    ) %>%
    ungroup() %>%
    arrange(VG, is_target) %>%
    mutate(
      is_target = ifelse(is_target, "Target", "Non-target")
    )
  
  # Save summary statistics
  write_csv(stats_summary, file.path(dir, "gene_stats_summary.csv"))
  
  # Return results invisibly
  invisible(list(
    gene_stats = gene_stats,
    stats_summary = stats_summary
  ))
}